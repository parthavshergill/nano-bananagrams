<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üçå Nano Banana Playground</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            image-rendering: pixelated;
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background: #8b7355;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(139, 115, 85, 0.3) 2px, rgba(139, 115, 85, 0.3) 4px),
                repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(139, 115, 85, 0.3) 2px, rgba(139, 115, 85, 0.3) 4px);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            background: #f4e4c1;
            padding: 20px;
            border: 4px solid #5d4e37;
            box-shadow: 
                4px 4px 0 rgba(0,0,0,0.3),
                inset 2px 2px 0 rgba(255,255,255,0.3);
        }

        h1 {
            color: #d4a574;
            font-size: 1.5em;
            text-shadow: 3px 3px 0 #8b6f47;
            line-height: 1.6;
        }

        h2 {
            font-size: 0.8em;
            line-height: 1.6;
        }

        h3 {
            font-size: 0.7em;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        p, li {
            font-size: 0.5em;
            line-height: 1.8;
        }

        .setup-panel {
            background: #f4e4c1;
            padding: 20px;
            border: 4px solid #5d4e37;
            margin-bottom: 20px;
            box-shadow: 
                4px 4px 0 rgba(0,0,0,0.3),
                inset 2px 2px 0 rgba(255,255,255,0.3);
        }

        .setup-panel input,
        .setup-panel textarea {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 3px solid #5d4e37;
            background: #fff9e6;
            font-size: 10px;
            font-family: 'Courier New', monospace;
        }

        .setup-panel button {
            background: #e89a3c;
            color: #fff;
            border: 3px solid #5d4e37;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 0.6em;
            font-family: 'Press Start 2P', cursive;
            margin-top: 10px;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
            transition: all 0.1s;
        }

        .setup-panel button:hover {
            background: #f5a94e;
            transform: translate(1px, 1px);
            box-shadow: 2px 2px 0 rgba(0,0,0,0.3);
        }

        .setup-panel button:active {
            transform: translate(3px, 3px);
            box-shadow: none;
        }

        .game-container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .board-section {
            background: #f4e4c1;
            padding: 20px;
            border: 4px solid #5d4e37;
            box-shadow: 
                4px 4px 0 rgba(0,0,0,0.3),
                inset 2px 2px 0 rgba(255,255,255,0.3);
        }

        .game-board {
            position: relative;
            background: #a8d5ba;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 20px, rgba(139, 115, 85, 0.1) 20px, rgba(139, 115, 85, 0.1) 21px),
                repeating-linear-gradient(90deg, transparent, transparent 20px, rgba(139, 115, 85, 0.1) 20px, rgba(139, 115, 85, 0.1) 21px);
            border: 4px solid #5d4e37;
            min-height: 500px;
            margin-bottom: 20px;
            box-shadow: inset 3px 3px 0 rgba(0,0,0,0.2);
        }

        .tile {
            position: relative;
            width: 50px;
            height: 50px;
            background: #f9d79c;
            border: 3px solid #5d4e37;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: move;
            user-select: none;
            box-shadow: 
                3px 3px 0 rgba(0,0,0,0.3),
                inset 1px 1px 0 rgba(255,255,255,0.5);
            transition: transform 0.1s;
            color: #5d4e37;
        }

        .tile:hover {
            transform: translate(-1px, -1px);
            box-shadow: 
                4px 4px 0 rgba(0,0,0,0.3),
                inset 1px 1px 0 rgba(255,255,255,0.5);
        }

        .tile.placeholder {
            visibility: hidden;
            pointer-events: none;
            box-shadow: none;
            border-color: transparent;
            background: transparent;
        }

        .tile.dragging {
            cursor: grabbing;
            pointer-events: none;
            transform: none !important;
            transition: none;
        }

        .tile.selected {
            background: #9ed99d;
            border-color: #4a7c59;
            box-shadow: 
                3px 3px 0 rgba(74, 124, 89, 0.5),
                inset 0 0 10px rgba(158, 217, 157, 0.8);
        }

        .tile-pool {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            background: #d4a574;
            border: 3px solid #5d4e37;
            min-height: 100px;
            box-shadow: inset 2px 2px 0 rgba(0,0,0,0.2);
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .controls button {
            background: #6ba8a9;
            color: white;
            border: 3px solid #5d4e37;
            padding: 10px 15px;
            cursor: pointer;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.5em;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
            transition: all 0.1s;
        }

        .controls button:hover {
            background: #7ebdbe;
            transform: translate(1px, 1px);
            box-shadow: 2px 2px 0 rgba(0,0,0,0.3);
        }

        .controls button:active {
            transform: translate(3px, 3px);
            box-shadow: none;
        }

        .controls button.danger {
            background: #c86858;
        }

        .controls button.danger:hover {
            background: #d87868;
        }

        .controls button:nth-child(3) {
            background: #a685d1;
        }

        .controls button:nth-child(3):hover {
            background: #b895e1;
        }

        .gallery {
            background: #f4e4c1;
            padding: 20px;
            border: 4px solid #5d4e37;
            box-shadow: 
                4px 4px 0 rgba(0,0,0,0.3),
                inset 2px 2px 0 rgba(255,255,255,0.3);
        }

        .gallery h2 {
            color: #d4a574;
            margin-bottom: 15px;
            text-shadow: 2px 2px 0 #8b6f47;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        .gallery-item {
            border: 3px solid #5d4e37;
            overflow: hidden;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
            background: white;
        }

        .gallery-item img {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-bottom: 3px solid #5d4e37;
        }

        .gallery-item .caption {
            padding: 8px;
            background: #f9d79c;
            font-size: 0.4em;
            text-align: center;
            color: #5d4e37;
        }

        .status {
            padding: 10px;
            background: #d4f4dd;
            border: 3px solid #5d4e37;
            margin-bottom: 15px;
            font-size: 0.5em;
            box-shadow: inset 1px 1px 0 rgba(0,0,0,0.1);
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #5d4e37;
            font-size: 0.5em;
        }

        .instructions {
            background: #fff9e6;
            padding: 15px;
            border: 3px solid #5d4e37;
            margin-bottom: 15px;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.2);
        }

        .instructions h3 {
            color: #d4a574;
            margin-bottom: 10px;
            text-shadow: 1px 1px 0 #8b6f47;
        }

        .instructions ul,
        .instructions ol {
            margin-left: 20px;
        }

        .instructions li {
            margin: 8px 0;
        }

        .instructions a {
            color: #6ba8a9;
            text-decoration: none;
        }

        .instructions a:hover {
            color: #7ebdbe;
        }

        @media (max-width: 900px) {
            .game-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üçå Nano Banana Playground üçå</h1>
            <p>Async Bananagrams with AI Image Generation!</p>
        </header>

        <div id="setup" class="setup-panel">
            <h2>Setup Required</h2>
            <p>Enter your Firebase and Google AI API credentials:</p>
            
            <h3>Firebase Config (JSON)</h3>
            <textarea id="firebaseConfig" rows="8" style="width: 100%; font-family: monospace; padding: 10px;">
{
  "apiKey": "YOUR_FIREBASE_API_KEY",
  "authDomain": "your-app.firebaseapp.com",
  "databaseURL": "https://your-app.firebaseio.com",
  "projectId": "your-project-id",
  "storageBucket": "your-app.appspot.com",
  "messagingSenderId": "123456789",
  "appId": "your-app-id"
}
            </textarea>

            <h3>Google AI API Key</h3>
            <input type="text" id="googleApiKey" placeholder="Your Google AI API Key">

            <button onclick="initializeApp()">Start Playing! üçå</button>

            <div class="instructions">
                <h3>Quick Setup Guide:</h3>
                <ol>
                    <li><strong>Firebase:</strong> Go to <a href="https://console.firebase.google.com" target="_blank">Firebase Console</a> ‚Üí Create project ‚Üí Realtime Database ‚Üí Copy config</li>
                    <li><strong>Google AI:</strong> Go to <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a> ‚Üí Get API Key</li>
                    <li>Paste both above and click Start Playing!</li>
                </ol>
            </div>
        </div>

        <div id="gameArea" style="display: none;">
            <div class="instructions">
                <h3>How to Play:</h3>
                <ul>
                    <li><strong>Draw Tiles:</strong> Click "Draw Tiles" to get 21 tiles to start</li>
                    <li><strong>Make Words:</strong> Drag tiles onto the board to spell words</li>
                    <li><strong>Select Words:</strong> Click tiles to select them (they turn green)</li>
                    <li><strong>Generate Art:</strong> Click "Generate Image" to turn selected words into AI art!</li>
                    <li><strong>Keep Playing:</strong> Your partner can join anytime - everything syncs automatically!</li>
                </ul>
            </div>

            <div class="game-container">
                <div>
                    <div class="board-section">
                        <div class="controls">
                            <button onclick="drawTiles()">üçå Draw Tiles</button>
                            <button onclick="clearSelection()">Clear Selection</button>
                            <button onclick="generateImage()" style="background: #a685d1;">‚ú® Generate Image</button>
                            <button onclick="resetGame()" class="danger">Reset Game</button>
                        </div>

                        <div class="status" id="status">
                            <strong>Tiles in Pile:</strong> <span id="pileCount">144</span> | 
                            <strong>Selected:</strong> <span id="selectedWord">none</span>
                        </div>

                        <h3>Game Board</h3>
                        <div class="game-board" id="gameBoard"></div>

                        <h3>Your Tiles</h3>
                        <div class="tile-pool" id="tilePool"></div>
                    </div>
                </div>

                <div>
                    <div class="gallery">
                        <h2>üé® Banana Art Gallery</h2>
                        <div id="galleryLoading" class="loading" style="display: none;">
                            Generating art... üé®
                        </div>
                        <div class="gallery-grid" id="galleryGrid"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load config.js if it exists -->
    <script src="config.js"></script>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, onValue, update, get } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';

        let db;
        let gameRef;
        let googleApiKey;
        let isDragging = false;
        let draggedTile = null;
        let offsetX, offsetY;
        let tilePlaceholder = null;

        // Auto-initialize if config.js is loaded
        window.addEventListener('DOMContentLoaded', () => {
            if (window.CONFIG && window.CONFIG.firebaseConfig && window.CONFIG.googleApiKey) {
                document.getElementById('firebaseConfig').value = JSON.stringify(window.CONFIG.firebaseConfig, null, 2);
                document.getElementById('googleApiKey').value = window.CONFIG.googleApiKey;
                
                // Auto-initialize after a brief delay to let user see the interface
                setTimeout(() => {
                    if (confirm('Found config.js! Auto-initialize the game?')) {
                        window.initializeApp();
                    }
                }, 500);
            }
        });

        // Bananagrams tile distribution
        const TILE_DISTRIBUTION = {
            'A': 13, 'B': 3, 'C': 3, 'D': 6, 'E': 18, 'F': 3, 'G': 4, 'H': 3,
            'I': 12, 'J': 2, 'K': 2, 'L': 5, 'M': 3, 'N': 8, 'O': 11, 'P': 3,
            'Q': 2, 'R': 9, 'S': 6, 'T': 9, 'U': 6, 'V': 3, 'W': 3, 'X': 2,
            'Y': 3, 'Z': 2
        };

        window.initializeApp = function() {
            try {
                const firebaseConfig = JSON.parse(document.getElementById('firebaseConfig').value);
                googleApiKey = document.getElementById('googleApiKey').value.trim();

                if (!googleApiKey) {
                    alert('Please enter your Google AI API key!');
                    return;
                }

                const app = initializeApp(firebaseConfig);
                db = getDatabase(app);
                gameRef = ref(db, 'nanoBananaGame');

                // Initialize game state if it doesn't exist
                onValue(gameRef, (snapshot) => {
                    if (!snapshot.exists()) {
                        initializeGameState();
                    } else {
                        renderGame(snapshot.val());
                    }
                });

                document.getElementById('setup').style.display = 'none';
                document.getElementById('gameArea').style.display = 'block';

                setupDragAndDrop();
            } catch (error) {
                alert('Error initializing: ' + error.message);
            }
        };

        function initializeGameState() {
            const tiles = [];
            let id = 0;
            for (const [letter, count] of Object.entries(TILE_DISTRIBUTION)) {
                for (let i = 0; i < count; i++) {
                    tiles.push({ id: id++, letter, location: 'pile' });
                }
            }

            const initialState = {
                tiles: tiles,
                gallery: []
            };

            set(gameRef, initialState);
        }

        // Helper function to convert tiles to array if needed (Firebase may return object)
        function tilesToArray(tiles) {
            if (Array.isArray(tiles)) {
                return tiles;
            }
            if (tiles && typeof tiles === 'object') {
                // Convert object with numeric keys to array
                const arr = [];
                const keys = Object.keys(tiles).sort((a, b) => parseInt(a) - parseInt(b));
                for (const key of keys) {
                    arr.push(tiles[key]);
                }
                return arr;
            }
            return [];
        }

        // Helper function to find tile index by tile.id
        function findTileIndex(tiles, tileId) {
            const tilesArray = tilesToArray(tiles);
            for (let i = 0; i < tilesArray.length; i++) {
                if (tilesArray[i] && tilesArray[i].id === tileId) {
                    return i;
                }
            }
            return -1;
        }

        // Helper function to clean up drag state
        function cleanupDragState(tileElement) {
            if (tileElement) {
                tileElement.classList.remove('dragging');
                tileElement.style.position = '';
                tileElement.style.zIndex = '';
                tileElement.style.left = '';
                tileElement.style.top = '';
                tileElement.style.margin = '';
                if (tileElement.parentNode === document.body) {
                    document.body.removeChild(tileElement);
                }
            }
            if (tilePlaceholder && tilePlaceholder.parentNode) {
                tilePlaceholder.parentNode.removeChild(tilePlaceholder);
            }
            tilePlaceholder = null;
            isDragging = false;
            draggedTile = null;
        }

        window.drawTiles = async function() {
            const snapshot = await get(gameRef);
            const data = snapshot.val();
            
            // Convert tiles to array format (Firebase may return object)
            const tiles = tilesToArray(data.tiles || []);
            const updates = {};
            let drawnCount = 0;
            
            // Iterate through tiles to find ones in pile
            // Use the actual array index which corresponds to Firebase's numeric key
            for (let i = 0; i < tiles.length && drawnCount < 21; i++) {
                if (tiles[i] && tiles[i].location === 'pile') {
                    // Use array index as Firebase key (Firebase stores arrays as {0: ..., 1: ..., ...})
                    updates[`tiles/${i}/location`] = 'pool';
                    drawnCount++;
                }
            }

            if (Object.keys(updates).length > 0) {
                await update(gameRef, updates);
            }
        };

        function renderGame(data) {
            const board = document.getElementById('gameBoard');
            const pool = document.getElementById('tilePool');
            
            // Clear existing
            board.innerHTML = '';
            pool.innerHTML = '';

            // Convert tiles to array format (Firebase may return object)
            const tiles = tilesToArray(data.tiles || []);

            // Render tiles
            tiles.forEach(tile => {
                if (!tile) return; // Skip null/undefined entries
                
                const tileEl = createTileElement(tile);
                
                if (tile.location === 'board') {
                    board.appendChild(tileEl);
                } else if (tile.location === 'pool') {
                    pool.appendChild(tileEl);
                }
            });

            // Update status
            const pileCount = tiles.filter(t => t && t.location === 'pile').length;
            document.getElementById('pileCount').textContent = pileCount;

            // Render gallery
            renderGallery(data.gallery || []);
        }

        function createTileElement(tile) {
            const div = document.createElement('div');
            div.className = 'tile';
            div.textContent = tile.letter;
            div.dataset.tileId = tile.id;
            
            if (tile.location === 'board') {
                div.style.position = 'absolute';
                div.style.left = (tile.x || 0) + 'px';
                div.style.top = (tile.y || 0) + 'px';
            } else {
                div.style.position = 'relative';
                div.style.left = '';
                div.style.top = '';
            }

            if (tile.selected) {
                div.classList.add('selected');
            }

            div.addEventListener('click', () => toggleTileSelection(tile.id));

            return div;
        }

        function setupDragAndDrop() {
            let startParent = null;

            document.addEventListener('mousedown', (e) => {
                const target = e.target;
                if (target.classList.contains('tile')) {
                    isDragging = true;
                    draggedTile = target;
                    startParent = draggedTile.parentElement;

                    const rect = draggedTile.getBoundingClientRect();
                    offsetX = e.clientX - rect.left;
                    offsetY = e.clientY - rect.top;

                    if (startParent && startParent.classList.contains('tile-pool')) {
                        tilePlaceholder = document.createElement('div');
                        tilePlaceholder.className = 'tile placeholder';
                        tilePlaceholder.style.width = rect.width + 'px';
                        tilePlaceholder.style.height = rect.height + 'px';
                        startParent.replaceChild(tilePlaceholder, draggedTile);
                    } else {
                        tilePlaceholder = null;
                    }

                    draggedTile.classList.add('dragging');
                    draggedTile.style.position = 'fixed';
                    draggedTile.style.zIndex = 1000;
                    draggedTile.style.left = (e.clientX - offsetX) + 'px';
                    draggedTile.style.top = (e.clientY - offsetY) + 'px';
                    draggedTile.style.margin = '0';

                    document.body.appendChild(draggedTile);

                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging && draggedTile) {
                    draggedTile.style.left = (e.clientX - offsetX) + 'px';
                    draggedTile.style.top = (e.clientY - offsetY) + 'px';
                }
            });

            document.addEventListener('mouseup', async (e) => {
                if (isDragging && draggedTile) {
                    const board = document.getElementById('gameBoard');
                    const boardRect = board.getBoundingClientRect();
                    const tileRect = draggedTile.getBoundingClientRect();

                    const tileCenterX = tileRect.left + tileRect.width / 2;
                    const tileCenterY = tileRect.top + tileRect.height / 2;
                    
                    const isOverBoard = (
                        tileCenterX >= boardRect.left &&
                        tileCenterX <= boardRect.right &&
                        tileCenterY >= boardRect.top &&
                        tileCenterY <= boardRect.bottom
                    );

                    const tileId = parseInt(draggedTile.dataset.tileId, 10);
                    const currentDraggedTile = draggedTile;

                    try {
                        const snapshot = await get(gameRef);
                        const data = snapshot.val();
                        const tiles = tilesToArray(data.tiles || []);
                        const tileIndex = findTileIndex(tiles, tileId);
                        
                        if (tileIndex === -1) {
                            console.error('Tile not found:', tileId);
                            return;
                        }

                        if (isOverBoard) {
                            let x = tileCenterX - boardRect.left - 25;
                            let y = tileCenterY - boardRect.top - 25;

                            x = Math.round(x / 55) * 55;
                            y = Math.round(y / 55) * 55;

                            x = Math.max(0, Math.min(x, boardRect.width - 50));
                            y = Math.max(0, Math.min(y, boardRect.height - 50));

                            await update(gameRef, {
                                [`tiles/${tileIndex}/location`]: 'board',
                                [`tiles/${tileIndex}/x`]: x,
                                [`tiles/${tileIndex}/y`]: y
                            });
                        } else {
                            if (tilePlaceholder && tilePlaceholder.parentNode) {
                                tilePlaceholder.parentNode.replaceChild(currentDraggedTile, tilePlaceholder);
                                tilePlaceholder = null;
                            } else if (startParent && startParent.classList.contains('tile-pool')) {
                                startParent.appendChild(currentDraggedTile);
                            }

                            await update(gameRef, {
                                [`tiles/${tileIndex}/location`]: 'pool',
                                [`tiles/${tileIndex}/x`]: null,
                                [`tiles/${tileIndex}/y`]: null
                            });
                        }
                    } catch (error) {
                        console.error('Error updating tile:', error);
                    } finally {
                        startParent = null;
                        cleanupDragState(currentDraggedTile);
                    }
                }
            });
        }

        async function toggleTileSelection(tileId) {
            const snapshot = await get(gameRef);
            const data = snapshot.val();
            const tiles = tilesToArray(data.tiles || []);
            const tileIndex = findTileIndex(tiles, tileId);
            
            if (tileIndex === -1) {
                console.error('Tile not found:', tileId);
                return;
            }
            
            const tile = tiles[tileIndex];
            
            await update(gameRef, {
                [`tiles/${tileIndex}/selected`]: !tile.selected
            });

            // Update selected word display
            setTimeout(async () => {
                const snap = await get(gameRef);
                const tilesArray = tilesToArray(snap.val().tiles || []);
                const selectedTiles = tilesArray
                    .filter(t => t && t.selected)
                    .map(t => t.letter)
                    .join('');
                document.getElementById('selectedWord').textContent = 
                    selectedTiles || 'none';
            }, 100);
        }

        window.clearSelection = async function() {
            const snapshot = await get(gameRef);
            const data = snapshot.val();
            const tiles = tilesToArray(data.tiles || []);
            const updates = {};
            
            tiles.forEach((tile, index) => {
                if (tile && tile.selected) {
                    updates[`tiles/${index}/selected`] = false;
                }
            });

            if (Object.keys(updates).length > 0) {
                await update(gameRef, updates);
            }
        };

        window.generateImage = async function() {
            const snapshot = await get(gameRef);
            const data = snapshot.val();
            const tiles = tilesToArray(data.tiles || []);
            const selectedTiles = tiles.filter(t => t && t.selected);
            
            if (selectedTiles.length === 0) {
                alert('Select some tiles first!');
                return;
            }

            const word = selectedTiles.map(t => t.letter).join('');
            
            document.getElementById('galleryLoading').style.display = 'block';

            try {
                // Using Gemini 2.5 Flash Image generation (correct model and API format)
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent?key=${googleApiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: `Create a cozy, whimsical pixel art style image of: ${word}`
                            }]
                        }],
                        generationConfig: {
                            responseModalities: ['Image']
                        }
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                console.log('API Response:', result);
                
                // Extract image from Gemini response
                if (result.candidates && result.candidates[0] && result.candidates[0].content) {
                    const parts = result.candidates[0].content.parts;
                    const imagePart = parts.find(part => part.inlineData);
                    
                    if (imagePart && imagePart.inlineData) {
                        const imageData = imagePart.inlineData.data;
                        const mimeType = imagePart.inlineData.mimeType || 'image/png';
                        const imageUrl = `data:${mimeType};base64,${imageData}`;

                        const gallery = data.gallery || [];
                        gallery.push({
                            word: word,
                            imageUrl: imageUrl,
                            timestamp: Date.now()
                        });

                        await update(gameRef, { gallery: gallery });
                        
                        // Clear selection
                        await window.clearSelection();
                    } else {
                        console.error('Response structure:', result);
                        alert('No image data in response. Check console for details.');
                    }
                } else {
                    console.error('Unexpected response structure:', result);
                    if (result.error) {
                        alert('Image generation failed: ' + result.error.message);
                    } else {
                        alert('Image generation failed: Unexpected response format. Check console for details.');
                    }
                }
            } catch (error) {
                alert('Error generating image: ' + error.message);
                console.error('Full error:', error);
            } finally {
                document.getElementById('galleryLoading').style.display = 'none';
            }
        };

        function renderGallery(gallery) {
            const grid = document.getElementById('galleryGrid');
            grid.innerHTML = '';

            if (gallery.length === 0) {
                grid.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #5d4e37;">No banana art yet! Select tiles and generate some! üé®</p>';
                return;
            }

            gallery.slice().reverse().forEach(item => {
                const div = document.createElement('div');
                div.className = 'gallery-item';
                div.innerHTML = `
                    <img src="${item.imageUrl}" alt="${item.word}">
                    <div class="caption">${item.word}</div>
                `;
                grid.appendChild(div);
            });
        }

        window.resetGame = function() {
            if (confirm('Reset the entire game? This will clear everything!')) {
                initializeGameState();
            }
        };
    </script>
</body>
</html>